#!/usr/bin/python
#coding=utf-8

import sys
import getopt 
import os
import signal
import subprocess
import random
import hashlib

import angr
from treelib import Node, Tree
import datetime
import signal
import time

class Node(object):  
	def __init__(self, node, pid, nid, next = []): 
		self.node = node ##angr node
		self.pid = pid ##func tree's id(root or angr prenode's addr+ current node's addr)
		self.nid = nid ##unique (angr prenode's addr+ current node's addr)
		#self.name = self.node.name
		self.name = str(nid)
		self.next = next

class SelfRuntimeOut(Exception):
    def __init__(self):
		pass
		
class FuncTree(object):  
	
	def __init__(self):
		self.map = {}
		self.maps = {}
		self.maps_info = {} #record information of each function, like function address, name, KEY_API_FLAG and so on.
		self.root = 1
		self.uniqueid = 1
		self.visited = []
		self.funclist = []##Node
		self.funcvisited = {}##func Node.node
		self.nodeVisited = {} #anger nodes from inside one function, node.addr:[Node.nid,...]
		self.cfg = None
		
	def dfs(self, tnode, functree):
		self.visited.append(tnode.nid)
		ret = []
		if tnode.nid == tnode.pid:##current func's first angr node
			if tnode.nid not in ret:
				ret.append(tnode.nid)
			self.funcvisited[tnode.node] = tnode
			functree.create_node(tnode.nid, tnode.nid, data=tnode)##
			#self.maps_info[tnode.nid] = [tnode.node.addr, tnode.node.name, tnode.node.is_syscall, tnode.node.syscall_name]
			if tnode.node.name == None:
				self.maps_info[tnode.nid] = [tnode.node.addr, "None"]
			else:
				self.maps_info[tnode.nid] = [tnode.node.addr, tnode.node.name]
		else:
			#print '44', tnode.node, tnode.nid
			if tnode.node.addr == tnode.node.function_address:##func(call/sys/some boring)
				if tnode.nid not in ret:
					ret.append(tnode.nid)
				#if tnode.node.name == None: 
				#	tnode.node.name = str(hex(tnode.node.function_address)) ##long-->str
				#	tnode.name = str(hex(tnode.node.function_address)) ##long-->str
				tnode.name = str(tnode.nid);
				##print '---55', tnode.node, tnode.nid, tnode.pid
				functree.create_node(tnode.nid, tnode.nid, parent=tnode.pid ,data=tnode)
				#self.maps_info[tnode.nid] = [tnode.node.addr, tnode.node.name, tnode.node.is_syscall, tnode.node.syscall_name]
				if tnode.node.name == None:
					self.maps_info[tnode.nid] = [tnode.node.addr, "None"]
				else:
					self.maps_info[tnode.nid] = [tnode.node.addr, tnode.node.name]
				if tnode.pid in self.map:
					if tnode.nid not in self.map[tnode.pid]:
						self.map[tnode.pid].append(tnode.nid)
				else:
					self.map[tnode.pid] = [tnode.nid,]
				newfuncnode = Node(tnode.node, tnode.nid, tnode.nid)##dont directly save tnode, cause its pid need change to node.addr for next dfs
				if newfuncnode not in self.funclist:##self.funclist store node's pid is node itself's addr
					self.funclist.append(newfuncnode)
				self.nodeVisited[tnode.node.addr] = ret
				return ret##dfs visit next tree node
		
		if tnode.node.addr in self.nodeVisited:
			_next = self.nodeVisited[tnode.node.addr]
			#print "-----------------------------------------------huha(0x%x)" %tnode.node.addr
			if len(_next) > 0:
				str0 = ""
				for i in _next:
					str0 += str(i) + ","
				#tnode.node.name = str0 ##long-->str
				tnode.name = str0 ##long-->str
				tnode.next = _next
				functree.create_node(tnode.nid, tnode.nid, parent=tnode.pid, data=tnode)
				if tnode.pid not in self.map:
					self.map[tnode.pid] = []
				for i in _next:
					if i not in self.map[tnode.pid]:
						self.map[tnode.pid].append(i)
						##_node = functree.get_node(i).data
						#self.maps_info[tnode.pid] = [_node.node.addr, _node.node.name, _node.node.is_syscall, _node.node.syscall_name]
						##self.maps_info[tnode.pid] = [_node.node.addr, _node.node.name]
			return _next
		
		self.nodeVisited[tnode.node.addr] = []
		nbsdict = {}
		nbslist = []
		nbs = []
		for nb, jumpkind in self.cfg.get_successors_and_jumpkind(tnode.node, excluding_fakeret = False):
			#if ((jumpkind == 'Ijk_Ret') or (((jumpkind == 'Ijk_FakeRet') or (jumpkind == 'Ijk_Boring')) and (nb.addr <= tnode.node.addr))):##solve loops, ignore ret
			if ((jumpkind == 'Ijk_Ret')):##solve loops, ignore ret
				continue
			nbsdict[jumpkind] = nb##three calls->update, anyway use nbslist. otherwise store FakeRet(only one)
			nbslist.append(nb)
		if (len(nbslist) >= 2) and ('Ijk_FakeRet' in nbsdict.keys()):##fakeret and call
			frnode = nbsdict['Ijk_FakeRet']
			nbslist.remove(frnode)
			if ('Ijk_Boring' in nbsdict.keys()):
				bnode = nbsdict['Ijk_Boring']
				nbslist.remove(bnode)
			if len(nbslist) > 0:##BUG
				self.uniqueid += 1
				newtnode = Node(nbslist[0], tnode.pid, self.uniqueid)##call 
				nbs.append(newtnode)
				self.uniqueid += 1
				newtnode1 = Node(frnode, newtnode.nid, self.uniqueid)##change fakeret's tree func's parent
				nbs.append(newtnode1)
		else:##dont hava fakeret, for :boring or boring(jmp) or calls
			for nbl in nbslist:
				self.uniqueid += 1
				newtnode = Node(nbl, tnode.pid, self.uniqueid)
				nbs.append(newtnode)
		for nb in nbs:
			##print '------in', nb.node, nb.nid
			if (nb.nid not in self.visited):
				_t = []
				_t = self.dfs(nb, functree)
				if (len(_t) > 0) and (nb.pid == tnode.pid):
					ret += _t
				self.nodeVisited[tnode.node.addr] = ret #for loops
		_l = []
		for i in ret:
			if i not in _l:
				_l.append(i)
		ret = _l
		self.nodeVisited[tnode.node.addr] = ret
		return ret
	
	def handle(signum, frame, others):  # 收到信号 SIGALRM 后的回调函数，第一个参数是信号的数字，第二个参数是the interrupted stack frame.
		raise SelfRuntimeOut()
		
	def run(self, file_path, _sf):
		signal.signal(signal.SIGALRM, self.handle)  # 设置信号和回调函数
		signal.alarm(60*60)  # 设置 num 秒的闹钟
		try:
			#while(True):
			#	pass
			#print "huha",file_path
			proj = angr.Project(file_path, auto_load_libs = False)
			#print "CFGFast start!"
			self.cfg = proj.analyses.CFGFast()
			#print "CFGFast done!"
		except SelfRuntimeOut as e:
			print "SelfRuntimeOut! ==>", file_path
			return None
		except Exception as e:
			print "Angr fail! ==>",file_path
			fp = open("./_angr_error.log", 'a')
			fp.write(datetime.datetime.now().strftime('|%Y-%m-%d %H:%M:%S|') + "Angr fail, path is " +\
					file_path + "," + e.message + "\n")
			fp.close()
			return False
		first = self.cfg.get_all_nodes(proj.entry, is_syscall = False)
		if len(first) < 1:##BUG
			print "first node get error!"
			fp = open("./_angr_error.log", 'a')
			fp.write(datetime.datetime.now().strftime('|%Y-%m-%d %H:%M:%S|') + "Angr fail, path is " + \
					file_path + ",There is no node after Angr's analyses!\n")
			fp.close()
			return False
		'''
		try:
			if first[0].name == None:
				first[0].name = "_start"
		except Exception as e:
			print "AngrNode.name change fail!"
		'''
		##entry function
		#functrees = []##func Node: Tree
		try:
			rootnode = Node(first[0], self.root, self.root)
			self.funclist.append(rootnode)
			
			##other function
			'''
			sf = "./result/" + file_path[file_path.rfind('/') + 1:] + ".res"
			sf_map = "./result/" + file_path[file_path.rfind('/') + 1:] + ".map"
			sf_map_info = "./result/" + file_path[file_path.rfind('/') + 1:] + ".info"
			'''
			sf = _sf + ".res";
			sf_map = _sf + ".map";
			sf_map_info = _sf + ".info";
			if os.path.exists(sf):
				os.remove(sf)
			if os.path.exists(sf_map):
				os.remove(sf_map)
			if os.path.exists(sf_map_info):
				os.remove(sf_map_info)
			for func in self.funclist:##self.funclist store Node
				if func.node not in self.funcvisited:
					huha_unique = self.uniqueid;
					self.map = {}
					tree = Tree()
					#functrees.append(tree)
					self.nodeVisited = {}
					self.dfs(func, tree)
					if len(self.map) < 1:
						continue
					tree.save2file(sf, data_property="name")
					self.maps[func.nid] = self.map
					fp = open(sf, 'a')
					fp.write('\n')
					fp.close()
					#tree.show(data_property="name")
					#print "---------------------------------------->%d" %(self.uniqueid - huha_unique)
				else:
					self.map = {}
					tree = Tree()
					#functrees.append(tree)
					tree.create_node(func.nid, func.nid, data=func)#root
					tfunc = self.funcvisited[func.node]
					tree.create_node(tfunc.nid, tfunc.nid, parent=func.nid, data=tfunc)
					if tfunc.node.name == None:
						self.maps_info[tfunc.nid] = [tfunc.node.addr, "None"]
					else:
						self.maps_info[tfunc.nid] = [tfunc.node.addr, tfunc.node.name]
					if func.nid in self.map:
						if tfunc.nid not in self.map[func.nid]:
							self.map[func.nid].append(tfunc.nid)
					else:
						self.map[func.nid] = [tfunc.nid,]
					tree.save2file(sf, data_property="name")
					self.maps[func.nid] = self.map
					fp = open(sf, 'a')
					fp.write('\n')
					fp.close()
					#tree.show(data_property="name")
					#print "<-------------------Found one!--------------------->"
			fp = open(sf_map, 'a')
			fp.write(str(self.maps))
			fp.close()
			#self.maps_info[self.root][1] = "_start"
			#print str(self.maps_info)
			self.maps_info[self.root][1] = "_start"
			fp = open(sf_map_info, 'a')
			fp.write(str(self.maps_info))
			fp.close()
		except Exception as e:
			print "run fail!"
			return False
		return True

		
		
class RouteFinder:
	def __init__(self, argv):
		self.argv = argv
		self.map = {}
		self.info = {}
		self.route = {}
		self.one_route = []
		self.max_len = {}
		self._min_len = 10
		self._max_len = 100
		self._max_count = 50
		self._route_len = 10
		self._route_count = 2
		self.routes = []
		self._count = {}
	
	def help(self):
		print "usage: python route_finder.py *.map *.info *.api"

	def map_reader(self):
		fp = None
		try:
			if(len(self.argv) < 4):
				self.help()
				return -1
			size = os.stat(self.argv[1]).st_size
			fp = open(self.argv[1], 'rb')
			fp.seek(0, 0)
			self.map = eval(fp.read(size))
			#print self.map
		except Exception as e:
			print "ERROR: file not exist or something else happend!"
			return -1
		finally:
			if(fp != None):
				fp.close()
		return 0
	
	def info_reader(self):
		try:
			if(len(self.argv) < 4):
				self.help()
				return -1
			size = os.stat(self.argv[2]).st_size
			fp = open(self.argv[2], 'rb')
			fp.seek(0, 0)
			self.info = eval(fp.read(size))
			#print self.info
		except Exception as e:
			print "ERROR: file not exist or something else happend!"
			return -1
		finally:
			if(fp != None):
				fp.close()
		return 0
	
	def dfs(self, index, start):#生成每个子图的所有路径
		if start not in self._count:
			self._count[start] = 0
		self._count[start] += 1
		if (start not in self.map[index]) or (len(self.one_route) > self.max_len[index]):#递归截止条件—长度限制、到达关键节点
			self.route[index].append([])
			self.route[index][len(self.route[index]) - 1] += self.one_route
			#print "dfs=>",self.one_route
			return
		for i in self.map[index][start]:
			#print "(",start,")",i,"->",
			if i in self._count and self._count[i] > self._max_count:#每个点的遍历次数不超过self._max_count
				continue
			self.one_route.append(i)
			self.dfs(index, i)
			del self.one_route[len(self.one_route) - 1]
		#print ""
	
	def _dfs(self, index, start):#统计一个子图所有节点的个数
		if start not in self._count:
			self._count[start] = 1
		if start not in self.map[index]:
			return
		for i in self.map[index][start]:
			if i in self._count:
				continue
			self._dfs(index, i)

	def dfs_route(self, index):
		if index >= len(self.one_route) or index >= self._route_len:
			if self.one_route[-1] in self.route:
				del self.one_route[len(self.one_route) - 1]
			self.routes.append(self.one_route[0:index])
			#print "dfs_route",index,"=>",self.routes[-1]
			return
		one_route_bk = self.one_route
		if one_route_bk[index] in self.route and (one_route_bk[index] not in self._count or self._count[one_route_bk[index]] < self._route_count):
			if one_route_bk[index] not in self._count:
				self._count[one_route_bk[index]] = 0
			else:
				self._count[one_route_bk[index]] += 1
			#print "one_route_bk = ", one_route_bk
			for i in self.route[one_route_bk[index]]:
				#print "i = ", i
				self.one_route = one_route_bk[:index] + i[1:] + one_route_bk[index + 1 :]
				self.dfs_route(index)
		else:
			self.dfs_route(index + 1)

	def run(self, label=None):
		if self.map_reader() < 0 or self.info_reader() < 0: #读入*map/*info内容到self.map/self.info中
			print "read input error!"
			self.help()
			return -1
		for i in self.map:
			self._count = {}
			self._dfs(i, i)
			self.max_len[i] = len(self._count) / 2
			if self.max_len[i] < self._min_len:
				self.max_len[i] = self._min_len
			elif self.max_len[i] > self._max_len:
				self.max_len[i] = self._max_len
		#print "before dfs"
		for i in self.map:
			self.route[i] = []
			self.one_route.append(i)
			self._count = {}
			self.dfs(i, i)
			#print self._count
			del self.one_route[len(self.one_route) - 1]
		#print self.route #get routes from each function
		#print "after dfs",len(self.route)
		'''
		for i in sorted(self.route.keys(), reverse = True):
			if (len(self.route[i]) == 1) and (i != 1):
				item = self.route.pop(i)[0]
				#print item
				for j in self.route:
					for _r in range(len(self.route[j])):
						r = self.route[j][_r]
						ele = []
						for e in r:
							if e == i:
								ele += item[1:]
							else:
								ele.append(e)
						self.route[j][_r] = ele
		'''
		self.one_route = [1,1]
		self._count = {}
		#print "before dfs_route"
		self.dfs_route(1)
		#print "after dfs_route",len(self.routes)
		res = ""
		for r in range(len(self.routes)):
			for j in range(len(self.routes[r])):
				self.routes[r][j] = self.info[self.routes[r][j]][1]
				
		_len = 0
		fp = open(self.argv[3], 'a')
		for r in self.routes:
			for j in r:
				#if j != "UnresolvableTarget" and j != "None":
				if j != "UnresolvableTarget":
					fp.write(j + " ")
					_len += 1
		#print "Final routes are: (%d)" %(len(res))
		#res = res[:len(res)]
		#fp = open(self.argv[3], 'a')
		if label is not None:
			fp.write(str(label) + "\n") #加上1/-1标签、换行，存储到一个文件中
		else:
			fp.write("\n")
		fp.close()
		return _len


def main():
	elflist = []
	for root, dirs, files in os.walk(sys.argv[1], topdown = False):
		for item in files:
			elflist.append(os.path.realpath(root + "/" + item))
	if len(elflist) < 1:
		print "No ELF file!"
		return
	icid = "default"
	
	try:
		fp = open(sys.argv[3], 'a')
		result = "./result"
		isExists = os.path.exists(result)
		if not isExists:
			os.makedirs(result)
		else:
			for root, dirs, files in os.walk(result, topdown=False):
				for item in files:
					os.remove(root + "/" + item)
		_res = []
		for item in elflist:
			_argv = [sys.argv[0], item]
			loc = result + "/"
			for i in item:
				if i == '.' or i == '/':
					loc += "_"
				else:
					loc += i
			_argv.append(loc)
			try:
				ft = FuncTree()
				_ret = ft.run(_argv[1], _argv[2])
				if _ret == True:
					_item = [_argv[2] + ".res", _argv[2] + ".map", _argv[2] + ".info", sys.argv[2], item]
					#print "huha"
					cti = RouteFinder(_item)
					_api_len = cti.run(sys.argv[4])
					#print "huha2"
					'''
					if _api_len < 20:#--------
						if os.path.exists(_item[3]):
							#print os.path.realpath(_item[3]),_item[3]
							os.remove(os.path.realpath(_item[3]))
						#print datetime.datetime.now().strftime('|%Y-%m-%d %H:%M:%S|') + "Router Too SHORT(" + _api_len + ")container id is" + icid + ",path is" + item[4]
						fp.write(datetime.datetime.now().strftime('|%Y-%m-%d %H:%M:%S|') + "Router Too SHORT(" + str(_api_len) + ")container id is" + icid + ",path is" + _item[4] + "\n")
					'''
					fp.write(datetime.datetime.now().strftime('|%Y-%m-%d %H:%M:%S|') + "Angr succ, container id is " + icid + ", path is " + item + "\n")
				elif _ret == False:
					#print datetime.datetime.now().strftime('|%Y-%m-%d %H:%M:%S|') + "Angr fail, container id is " + icid + ", path is " + item
					fp.write(datetime.datetime.now().strftime('|%Y-%m-%d %H:%M:%S|') + "Angr fail, container id is " + icid + ", path is " + item + "\n")
				else:
					fp.write(datetime.datetime.now().strftime('|%Y-%m-%d %H:%M:%S|') + "RuntimeOut, container id is " + icid + ", path is " + item + "\n")
			except Exception as e:
				print e.message
				#print datetime.datetime.now().strftime('|%Y-%m-%d %H:%M:%S|') + "RuntimeOut, container id is " + icid + ", path is " + item
				fp.write(datetime.datetime.now().strftime('|%Y-%m-%d %H:%M:%S|') + "Something wrong, container id is " + icid + ", path is " + item + "\n")
	except Exception as e:
		print datetime.datetime.now().strftime('|%Y-%m-%d %H:%M:%S|') + "something wrong happend!"
	finally:
		fp.close()
	return

def help():
	print sys.argv[0] + " path_to_elf path_to_data path_to_log"
	
def prepare():
	isExists = os.path.exists(sys.argv[1])
	if not isExists:
		print "Not exists!"
		return False
	fp = open(sys.argv[2], 'a')
	fp.write(datetime.datetime.now().strftime('|%Y-%m-%d %H:%M:%S|') + "Start analysising!\n")
	fp.close()
	fp = open(sys.argv[3], 'a')
	fp.write(datetime.datetime.now().strftime('|%Y-%m-%d %H:%M:%S|') + "Start analysising and loging!\n")
	fp.close()
	return True
	
if __name__ == "__main__":
	if len(sys.argv) < 4:
		help()
		exit()
	if len(sys.argv) == 4:
		sys.argv.append(None)
	if prepare() != True:
		help()
		exit()
	main()
