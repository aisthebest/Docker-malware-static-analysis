#!/usr/bin/python
#coding=utf-8

# python getelf.py -c 容器id/容器name/镜像id（以逗号分割多个） -d 指定目录（以逗号分割）

# python getelf.py -c 68b4a7cdaf58 -d /home/,/home/jin
# container list: 68b4a7cdaf58
# directory list: /home/,/home/jin
# tmp directory: 92
# container:68b4a7cdaf58, elflist:['./92/merged/home/jin/huha', './92/merged/home/huha1', './92/merged/home/huha', './92/merged/home/jin/huha']

# python getelf.py -c f5b668f50b6e,68b4a7cdaf58 -d /home/,/home/jin
# container list: f5b668f50b6e,68b4a7cdaf58
# directory list: /home/,/home/jin
# tmp directory: 70
# ------ERROR: directory "/home/jin" does not exists in container "f5b668f50b6e"
# container:f5b668f50b6e, elflist:[]
# tmp directory: 98
# container:68b4a7cdaf58, elflist:['./98/merged/home/jin/huha', './98/merged/home/huha1', './98/merged/home/huha', './98/merged/home/jin/huha']

import sys
import getopt 
import os
import signal
import subprocess
# import commands
import random
import hashlib

import angr
from treelib import Node, Tree
import datetime
import signal
import time

class Node(object):  
	def __init__(self, node, pid, nid, next = []): 
		self.node = node ##angr node
		self.pid = pid ##func tree's id(root or angr prenode's addr+ current node's addr)
		self.nid = nid ##unique (angr prenode's addr+ current node's addr)
		#self.name = self.node.name
		self.name = str(nid)
		self.next = next

class SelfRuntimeOut(Exception):
    def __init__(self):
		pass
		
class FuncTree(object):  
	
	def __init__(self):
		self.map = {}
		self.maps = {}
		self.maps_info = {} #record information of each function, like function address, name, KEY_API_FLAG and so on.
		self.root = 1
		self.uniqueid = 1
		self.visited = []
		self.funclist = []##Node
		self.funcvisited = {}##func Node.node
		self.nodeVisited = {} #anger nodes from inside one function, node.addr:[Node.nid,...]
		self.cfg = None
		
	def dfs(self, tnode, functree):
		self.visited.append(tnode.nid)
		ret = []
		if tnode.nid == tnode.pid:##current func's first angr node
			if tnode.nid not in ret:
				ret.append(tnode.nid)
			self.funcvisited[tnode.node] = tnode
			functree.create_node(tnode.nid, tnode.nid, data=tnode)##
			#self.maps_info[tnode.nid] = [tnode.node.addr, tnode.node.name, tnode.node.is_syscall, tnode.node.syscall_name]
			if tnode.node.name == None:
				self.maps_info[tnode.nid] = [tnode.node.addr, "None"]
			else:
				self.maps_info[tnode.nid] = [tnode.node.addr, tnode.node.name]
		else:
			#print '44', tnode.node, tnode.nid
			if tnode.node.addr == tnode.node.function_address:##func(call/sys/some boring)
				if tnode.nid not in ret:
					ret.append(tnode.nid)
				#if tnode.node.name == None: 
				#	tnode.node.name = str(hex(tnode.node.function_address)) ##long-->str
				#	tnode.name = str(hex(tnode.node.function_address)) ##long-->str
				tnode.name = str(tnode.nid);
				##print '---55', tnode.node, tnode.nid, tnode.pid
				functree.create_node(tnode.nid, tnode.nid, parent=tnode.pid ,data=tnode)
				#self.maps_info[tnode.nid] = [tnode.node.addr, tnode.node.name, tnode.node.is_syscall, tnode.node.syscall_name]
				if tnode.node.name == None:
					self.maps_info[tnode.nid] = [tnode.node.addr, "None"]
				else:
					self.maps_info[tnode.nid] = [tnode.node.addr, tnode.node.name]
				if tnode.pid in self.map:
					if tnode.nid not in self.map[tnode.pid]:
						self.map[tnode.pid].append(tnode.nid)
				else:
					self.map[tnode.pid] = [tnode.nid,]
				newfuncnode = Node(tnode.node, tnode.nid, tnode.nid)##dont directly save tnode, cause its pid need change to node.addr for next dfs
				if newfuncnode not in self.funclist:##self.funclist store node's pid is node itself's addr
					self.funclist.append(newfuncnode)
				self.nodeVisited[tnode.node.addr] = ret
				return ret##dfs visit next tree node
		
		if tnode.node.addr in self.nodeVisited:
			_next = self.nodeVisited[tnode.node.addr]
			#print "-----------------------------------------------huha(0x%x)" %tnode.node.addr
			if len(_next) > 0:
				str0 = ""
				for i in _next:
					str0 += str(i) + ","
				#tnode.node.name = str0 ##long-->str
				tnode.name = str0 ##long-->str
				tnode.next = _next
				functree.create_node(tnode.nid, tnode.nid, parent=tnode.pid, data=tnode)
				if tnode.pid not in self.map:
					self.map[tnode.pid] = []
				for i in _next:
					if i not in self.map[tnode.pid]:
						self.map[tnode.pid].append(i)
						##_node = functree.get_node(i).data
						#self.maps_info[tnode.pid] = [_node.node.addr, _node.node.name, _node.node.is_syscall, _node.node.syscall_name]
						##self.maps_info[tnode.pid] = [_node.node.addr, _node.node.name]
			return _next
		
		self.nodeVisited[tnode.node.addr] = []
		nbsdict = {}
		nbslist = []
		nbs = []
		for nb, jumpkind in self.cfg.get_successors_and_jumpkind(tnode.node, excluding_fakeret = False):
			#if ((jumpkind == 'Ijk_Ret') or (((jumpkind == 'Ijk_FakeRet') or (jumpkind == 'Ijk_Boring')) and (nb.addr <= tnode.node.addr))):##solve loops, ignore ret
			if ((jumpkind == 'Ijk_Ret')):##solve loops, ignore ret
				continue
			nbsdict[jumpkind] = nb##three calls->update, anyway use nbslist. otherwise store FakeRet(only one)
			nbslist.append(nb)
		if (len(nbslist) >= 2) and ('Ijk_FakeRet' in nbsdict.keys()):##fakeret and call
			frnode = nbsdict['Ijk_FakeRet']
			nbslist.remove(frnode)
			if ('Ijk_Boring' in nbsdict.keys()):
				bnode = nbsdict['Ijk_Boring']
				nbslist.remove(bnode)
			if len(nbslist) > 0:##BUG
				self.uniqueid += 1
				newtnode = Node(nbslist[0], tnode.pid, self.uniqueid)##call 
				nbs.append(newtnode)
				self.uniqueid += 1
				newtnode1 = Node(frnode, newtnode.nid, self.uniqueid)##change fakeret's tree func's parent
				nbs.append(newtnode1)
		else:##dont hava fakeret, for :boring or boring(jmp) or calls
			for nbl in nbslist:
				self.uniqueid += 1
				newtnode = Node(nbl, tnode.pid, self.uniqueid)
				nbs.append(newtnode)
		for nb in nbs:
			##print '------in', nb.node, nb.nid
			if (nb.nid not in self.visited):
				_t = []
				_t = self.dfs(nb, functree)
				if (len(_t) > 0) and (nb.pid == tnode.pid):
					ret += _t
				self.nodeVisited[tnode.node.addr] = ret #for loops
		_l = []
		for i in ret:
			if i not in _l:
				_l.append(i)
		ret = _l
		self.nodeVisited[tnode.node.addr] = ret
		return ret
	
	def handle(signum, frame, others):  # 收到信号 SIGALRM 后的回调函数，第一个参数是信号的数字，第二个参数是the interrupted stack frame.
		raise SelfRuntimeOut()
		
	def run(self, file_path, _sf):
		signal.signal(signal.SIGALRM, self.handle)  # 设置信号和回调函数
		signal.alarm(60*20)  # 设置 num 秒的闹钟
		try:
			#while(True):
			#	pass
			#print "huha",file_path
			proj = angr.Project(file_path, auto_load_libs = False)
			#print "CFGFast start!"
			self.cfg = proj.analyses.CFGFast()
			#print "CFGFast done!"
		except SelfRuntimeOut as e:
			print "SelfRuntimeOut! ==>", file_path
			return None
		except Exception as e:
			print "Angr fail! ==>",file_path
			fp = open("./_angr_error.log", 'a')
			fp.write(datetime.datetime.now().strftime('|%Y-%m-%d %H:%M:%S|') + "Angr fail, path is " + file_path + ","+ e.message + "\n")
			fp.close()
			return False
		first = self.cfg.get_all_nodes(proj.entry, is_syscall = False)
		if len(first) < 1:##BUG
			print "first node get error! ==>",file_path
			fp = open("./_angr_error.log", 'a')
			fp.write(datetime.datetime.now().strftime('|%Y-%m-%d %H:%M:%S|') + "Angr fail, path is " + file_path + ",There is no node after Angr's analyses!\n")
			fp.close()
			return False
		'''
		try:
			if first[0].name == None:
				first[0].name = "_start"
		except Exception as e:
			print "AngrNode.name change fail!"
		'''
		##entry function
		#functrees = []##func Node: Tree
		try:
			rootnode = Node(first[0], self.root, self.root)
			self.funclist.append(rootnode)
			
			##other function
			'''
			sf = "./result/" + file_path[file_path.rfind('/') + 1:] + ".res"
			sf_map = "./result/" + file_path[file_path.rfind('/') + 1:] + ".map"
			sf_map_info = "./result/" + file_path[file_path.rfind('/') + 1:] + ".info"
			'''
			sf = _sf + ".res";
			sf_map = _sf + ".map";
			sf_map_info = _sf + ".info";
			if os.path.exists(sf):
				os.remove(sf)
			if os.path.exists(sf_map):
				os.remove(sf_map)
			if os.path.exists(sf_map_info):
				os.remove(sf_map_info)
			for func in self.funclist:##self.funclist store Node
				if func.node not in self.funcvisited:
					huha_unique = self.uniqueid;
					self.map = {}
					tree = Tree()
					#functrees.append(tree)
					self.nodeVisited = {}
					self.dfs(func, tree)
					if len(self.map) < 1:
						continue
					tree.save2file(sf, data_property="name")
					self.maps[func.nid] = self.map
					fp = open(sf, 'a')
					fp.write('\n')
					fp.close()
					#tree.show(data_property="name")
					#print "---------------------------------------->%d" %(self.uniqueid - huha_unique)
				else:
					self.map = {}
					tree = Tree()
					#functrees.append(tree)
					tree.create_node(func.nid, func.nid, data=func)#root
					tfunc = self.funcvisited[func.node]
					tree.create_node(tfunc.nid, tfunc.nid, parent=func.nid, data=tfunc)
					if tfunc.node.name == None:
						self.maps_info[tfunc.nid] = [tfunc.node.addr, "None"]
					else:
						self.maps_info[tfunc.nid] = [tfunc.node.addr, tfunc.node.name]
					if func.nid in self.map:
						if tfunc.nid not in self.map[func.nid]:
							self.map[func.nid].append(tfunc.nid)
					else:
						self.map[func.nid] = [tfunc.nid,]
					tree.save2file(sf, data_property="name")
					self.maps[func.nid] = self.map
					fp = open(sf, 'a')
					fp.write('\n')
					fp.close()
					#tree.show(data_property="name")
					#print "<-------------------Found one!--------------------->"
			fp = open(sf_map, 'a')
			fp.write(str(self.maps))
			fp.close()
			#self.maps_info[self.root][1] = "_start"
			#print str(self.maps_info)
			self.maps_info[self.root][1] = "_start"
			fp = open(sf_map_info, 'a')
			fp.write(str(self.maps_info))
			fp.close()
		except Exception as e:
			print "run fail!"
			return False
		return True

		
class RouteFinder:
	def __init__(self, argv):
		self.argv = argv
		self.map = {}
		self.info = {}
		self.route = {}
		self.one_route = []
		self.max_len = {}
		self._min_len = 10
		self._max_len = 100
		self._max_count = 50
		self._route_len = 10
		self._route_count = 2
		self.routes = []
		self._count = {}
	
	def help(self):
		print "usage: python route_finder.py *.map *.info *.api"

	def map_reader(self):
		fp = None
		try:
			if(len(self.argv) < 4):
				self.help()
				return -1
			size = os.stat(self.argv[1]).st_size
			fp = open(self.argv[1], 'rb')
			fp.seek(0, 0)
			self.map = eval(fp.read(size))
			#print self.map
		except Exception as e:
			print "ERROR: file not exist or something else happend!"
			return -1
		finally:
			if(fp != None):
				fp.close()
		return 0
	
	def info_reader(self):
		try:
			if(len(self.argv) < 4):
				self.help()
				return -1
			size = os.stat(self.argv[2]).st_size
			fp = open(self.argv[2], 'rb')
			fp.seek(0, 0)
			self.info = eval(fp.read(size))
			#print self.info
		except Exception as e:
			print "ERROR: file not exist or something else happend!"
			return -1
		finally:
			if(fp != None):
				fp.close()
		return 0
	
	def dfs(self, index, start):#生成每个子图的所有路径
		if start not in self._count:
			self._count[start] = 0
		self._count[start] += 1
		if (start not in self.map[index]) or (len(self.one_route) > self.max_len[index]):#递归截止条件—长度限制、到达关键节点
			self.route[index].append([])
			self.route[index][len(self.route[index]) - 1] += self.one_route
			#print "dfs=>",self.one_route
			return
		for i in self.map[index][start]:
			#print "(",start,")",i,"->",
			if i in self._count and self._count[i] > self._max_count:#每个点的遍历次数不超过self._max_count
				continue
			self.one_route.append(i)
			self.dfs(index, i)
			del self.one_route[len(self.one_route) - 1]
		#print ""
	
	def _dfs(self, index, start):#统计一个子图所有节点的个数
		if start not in self._count:
			self._count[start] = 1
		if start not in self.map[index]:
			return
		for i in self.map[index][start]:
			if i in self._count:
				continue
			self._dfs(index, i)

	def dfs_route(self, index):
		if index >= len(self.one_route) or index >= self._route_len:
			if self.one_route[-1] in self.route:
				del self.one_route[len(self.one_route) - 1]
			self.routes.append(self.one_route[0:index])
			#print "dfs_route",index,"=>",self.routes[-1]
			return
		one_route_bk = self.one_route
		if one_route_bk[index] in self.route and (one_route_bk[index] not in self._count or self._count[one_route_bk[index]] < self._route_count):
			if one_route_bk[index] not in self._count:
				self._count[one_route_bk[index]] = 0
			else:
				self._count[one_route_bk[index]] += 1
			#print "one_route_bk = ", one_route_bk
			for i in self.route[one_route_bk[index]]:
				#print "i = ", i
				self.one_route = one_route_bk[:index] + i[1:] + one_route_bk[index + 1 :]
				self.dfs_route(index)
		else:
			self.dfs_route(index + 1)

	def run(self):
		if self.map_reader() < 0 or self.info_reader() < 0: #读入*map/*info内容到self.map/self.info中
			print "read input error!"
			self.help()
			return -1
		for i in self.map:
			self._count = {}
			self._dfs(i, i)
			self.max_len[i] = len(self._count) / 2
			if self.max_len[i] < self._min_len:
				self.max_len[i] = self._min_len
			elif self.max_len[i] > self._max_len:
				self.max_len[i] = self._max_len
		#print "before dfs"
		for i in self.map:
			self.route[i] = []
			self.one_route.append(i)
			self._count = {}
			self.dfs(i, i)
			#print self._count
			del self.one_route[len(self.one_route) - 1]
		#print self.route #get routes from each function
		#print "after dfs",len(self.route)
		'''
		for i in sorted(self.route.keys(), reverse = True):
			if (len(self.route[i]) == 1) and (i != 1):
				item = self.route.pop(i)[0]
				#print item
				for j in self.route:
					for _r in range(len(self.route[j])):
						r = self.route[j][_r]
						ele = []
						for e in r:
							if e == i:
								ele += item[1:]
							else:
								ele.append(e)
						self.route[j][_r] = ele
		'''
		self.one_route = [1,1]
		self._count = {}
		#print "before dfs_route"
		self.dfs_route(1)
		#print "after dfs_route",len(self.routes)
		res = ""
		for r in range(len(self.routes)):
			for j in range(len(self.routes[r])):
				self.routes[r][j] = self.info[self.routes[r][j]][1]
		_len = 0
		fp = open(self.argv[3], 'a')
		for r in self.routes:
			for j in r:
				#if j != "UnresolvableTarget" and j != "None":
				if j != "UnresolvableTarget":
					fp.write(j + " ")
					_len += 1
		
		#print "Final routes are: (%d)" %(len(res))
		#res = res[:len(res)]
		#fp = open(self.argv[3], 'a')
		#fp.write(str(label) + "\n") #加上1/-1标签、换行，存储到一个文件中
		fp.write("\n") #加上换行，存储到一个文件中
		fp.close()
		return _len

		
driver=""
overlay_cleanc=""
def overlay2(icid, dirnamearg):
	global overlay_cleanc
	# print 'tmp directory:',icid
	command = "docker inspect -f '{{.GraphDriver.Data.LowerDir}},{{.GraphDriver.Data.UpperDir}}' %s" % (icid) 
	fp = os.popen(command, "r")
	dirret = fp.read()
	mountdirlist = []##lowerdir,upperdir
	for mountnum, mountdir in enumerate(dirret.split(","), 1):
		mountdirlist.append(mountdir.strip('\n'))

	if mountdirlist[0] == '<no value>':##镜像id，没有lowerdir
		mountc = "mkdir ./%s && mkdir ./%s/upper ./%s/work ./%s/merged \
		&& mount -t overlay overlay -o lowerdir=%s,upperdir=./%s/upper,workdir=./%s/work ./%s/merged" \
		% (icid, icid, icid, icid, mountdirlist[1], icid, icid, icid)
		os.popen(mountc)
	else:##容器id/name（不管是否运行，这里是mount，所以容器层和镜像层内容都会有）
		lowerdirs = "%s:%s" % (mountdirlist[1], mountdirlist[0])##将lowerdir和upperdir拼接为mount时的lowerdir，只读，不破坏原有容器
		mountc = "mkdir ./%s && mkdir ./%s/upper ./%s/work ./%s/merged \
		&& mount -t overlay overlay -o lowerdir=%s,upperdir=./%s/upper,workdir=./%s/work ./%s/merged" \
		% (icid, icid, icid, icid, lowerdirs, icid, icid, icid)
		os.popen(mountc)
	overlay_cleanc="umount ./%s/merged && rm -fr %s" % (icid, icid)
	return

def overlay(icid, dirnamearg):
	global overlay_cleanc
	command = "docker inspect -f '{{.GraphDriver.Data.RootDir}}' %s" % (icid) 
	fp = os.popen(command, "r")
	rootdir = fp.read().strip('\n')
	if rootdir!="<no value>":##输入的是镜像id，只有rootdir一层
		mountc = "mkdir ./%s && mkdir ./%s/upper ./%s/work ./%s/merged \
		&& mount -t overlay overlay -o lowerdir=%s,upperdir=./%s/upper,workdir=./%s/work ./%s/merged" \
		% (icid, icid, icid, icid, rootdir, icid, icid, icid)
		os.popen(mountc)
	else:
		command = "docker inspect -f '{{.GraphDriver.Data.LowerDir}},{{.GraphDriver.Data.UpperDir}}' %s" % (icid) 
		fp = os.popen(command, "r")
		dirret = fp.read()
		mountdirlist = []##lowerdir,upperdir
		for mountnum, mountdir in enumerate(dirret.split(","), 1):
			mountdirlist.append(mountdir.strip('\n'))
		mountc = "mkdir ./%s && mkdir ./%s/work ./%s/merged \
		&& mount -t overlay overlay -o lowerdir=%s,upperdir=%s,workdir=./%s/work ./%s/merged" \
		% (icid, icid, icid, mountdirlist[0], mountdirlist[1], icid, icid)
		os.popen(mountc)

	overlay_cleanc="umount ./%s/merged && rm -fr %s" % (icid, icid)
	return

dm_cleanc=""
def devicemapper(icid,dirnamearg):
	global dm_cleanc
	command = "docker inspect -f '{{.GraphDriver.Data.DeviceId}},{{.GraphDriver.Data.DeviceName}}' %s" % (icid) 
	fp = os.popen(command, "r")
	ret = fp.read()
	id_name=[]
	for i, tmp in enumerate(ret.split(","), 1):
		id_name.append(tmp)
	id_name[-1]=id_name[-1].split('-')[-1].strip('\n')

	fp=os.popen("dmsetup table | grep -v thin-pool | grep thin | awk '{print $(NF-4),$(NF-3),$(NF-2),$(NF-1)}' |sort -u","r")
	ret=fp.read()
	pres=[]
	ret=""
	if ret=="":##没有正在运行中的容器，不可通过上述方法得到卷表信息。那就只能看有几个pool，按照默认10G一个容器卷，每次扩大2.5倍来构造信息
		fp=os.popen("dmsetup table | grep pool | awk '{print $1}'", "r")
		ret=fp.read()
		i=0
		pools=[]##若扩容，卷变大（要看每次扩大设置多少，58的一个pool是100G，每个容器10G，每次扩大是2.5倍，能扩大4次（即4个pool
		while i<len(ret.split('\n'))-1:
			pools.append(ret.split('\n')[i].strip(':'))
			i+=1
		# print('----',pools)
		volume_size=20971520 ##默认每个容器10G
		size_add=int(20971520*2.5)##默认每次增长2.5倍
		for pool in pools:
			major_minorc="dmsetup info %s | grep Major | awk '{print $(NF-1) $NF}'" % (pool)##得到设备号
			fp=os.popen(major_minorc,"r")
			major_minor=fp.read().strip('\n')
			pre="0 %d thin %s" % (volume_size,major_minor.replace(',',':'))
			pres.append(pre)##用于后面拼凑出table信息：0 20971520 thin 253:1 63（device_ind）
			volume_size+=size_add
	else:
		i=0
		while i<len(ret.split('\n'))-1:
			pres.append(ret.split('\n')[i])
			i+=1
	# print('pres',pres)
	for pre in pres:
		createc="dmsetup create %s --table '%s %s'" % (id_name[-1],pre,id_name[0])
		# print(createc)
		(ret, output) = subprocess.getstatusoutput(createc)##成功返回0，失败返回1.失败是因不是对的pool（python3）
		# (ret, output) = commands.getstatusoutput(createc)##python2
		# print(ret,output)
		if ret==0:
			mountc="mkdir ./%s && mount /dev/mapper/%s ./%s" % (icid,id_name[-1],icid)
			# print(mountc)
			(ret, output) = subprocess.getstatusoutput(mountc)##成功返回0，失败返回1.失败是因不是对的pool
			# (ret, output) = commands.getstatusoutput(mountc)
			# print(ret,output)
	
	##结束分析，需要取消挂载、取消激活并删除临时目录，构造命令用于dir2elf
	dm_cleanc = "umount ./%s && dmsetup remove %s && rm -fr %s" % (icid, id_name[-1], icid)
	# os.popen(cleanc)
	return

aufs_cleanc=""
cidname=[]
imageid=[]
def aufs(icid,dirnamearg):
	global aufs_cleanc
	if icid in cidname:##输入的是容器id/name，有mount-id，通过mount-id可以查看底层所有的cache-id
		command = "docker inspect -f '{{.Id}},{{.HostsPath}}' %s" % (icid) 
		fp = os.popen(command, "r")
		ret = fp.read()
		id_drootdir=[]
		for i, tmp in enumerate(ret.split(","), 1):
			id_drootdir.append(tmp)
		id_drootdir[-1]=id_drootdir[-1][0:id_drootdir[-1].index('containers')]##得到docker root dir 如：/var/lib/docker/
		# print('id_drootdir',id_drootdir)

		mount_id_path="%simage/aufs/layerdb/mounts/%s" % (id_drootdir[-1],id_drootdir[0])
		# isExists=os.path.exists(mount_id_path)##如果该目录存在，表明输入的是容器（运行/stop）
		# if isExists==1:
		mount_id_filec="cat %s/mount-id" % (mount_id_path)
		# print('mount_id_file',mount_id_filec)
		fp=os.popen(mount_id_filec, "r")
		# print('fp',fp)
		mount_id=fp.read()
		# print('mount_id',mount_id)
		# layers_path="%saufs/layers" % (id_drootdir[-1])##查看该容器层底层的文件系统层次，包括cache-id
		diff_ids_file="cat %saufs/layers/%s" % (id_drootdir[-1],mount_id)##查看该容器层 底层cache-id,并保留文件系统层次关系
		fp=os.popen(diff_ids_file,"r")
		diff_ids_raw=fp.read()
		diff_ids=[]##包含文件系统各层，从最高层开始，即0为最上层
		diff_ids.append(mount_id)##第一层，最上层，一般是rw
		i=0
		while i<len(diff_ids_raw.split('\n'))-1:
			diff_ids.append(diff_ids_raw.split('\n')[i])
			i+=1
		# print('diff_ids',diff_ids)
		d_root_dir=id_drootdir[-1]##为了后面统一处理
		cache_ids=diff_ids
	else:##输入的是镜像id
		# print('its images id')
		command = "docker inspect -f '{{.RootFS.Layers}}' %s" % (icid)##diff_id是从底层到高层 
		fp=os.popen(command,"r")
		ret=fp.read()
		diff_ids=[]
		for diff_id in ret.split(' '):
			diff_id=diff_id[diff_id.index(':')+1:]
			diff_id=diff_id.strip(']\n')
			diff_ids.append(diff_id)
		chain_ids=[]
		chain_ids.append(diff_ids[0])##最底层的chain_id和diff_id一样，此处从最底层开始存储
		for i,diff_id in enumerate(diff_ids):
			if i==0:
				continue
			else:
				pre_chain_id="sha256:%s sha256:%s" % (chain_ids[-1],diff_id)##从倒数第二层开始计算,以上一层的chain_id和这一层的diff_id合并计算sha256得到该层的chain_id
				# print('pre_chain_id',pre_chain_id)
				chian_id=hashlib.sha256(pre_chain_id).hexdigest()
				# print('chain_id',chian_id)
				chain_ids.append(chian_id)
		# print('chain_id',chain_ids)
		fp=os.popen("docker info | grep Docker","r")
		ret=fp.read()
		d_root_dir=ret[ret.index(':')+2:].strip('\n')+'/'##/var/lib/docker/
		# print('d_root_dir',d_root_dir)
		cache_ids=[]
		for chain_id in chain_ids:
			cache_idc="cat %simage/aufs/layerdb/sha256/%s/cache-id" % (d_root_dir,chain_id)
			fp=os.popen(cache_idc,"r")
			cache_id=fp.read()##每一层的cache_id
			cache_ids.append(cache_id)##从最底层到最高层，最底层需要放到mount时，br的最后一个
		cache_ids.reverse()##第一个为最高层，即mount时候的br0

	diff_path_pre="%saufs/diff/" % (d_root_dir)##存放具体文件系统内容的目录
	diff_paths=[]
	for i in range(len(cache_ids)):
		diff_path="%s%s" % (diff_path_pre,cache_ids[i])##如/var/lib/docker/aufs/diff/4e20c767c84f311a726451846fbdc7d3d09c7fe8a0ba31843adce1d49ec34bbe（cache-id
		diff_paths.append(diff_path)
	brs=""
	for diff_path in diff_paths:
		brs=brs+diff_path+"=ro:"
	brs=brs.strip(':')
	# print('brs',brs)
	mountc="mkdir ./%s && mount -t aufs -o br=%s none ./%s" % (icid,brs,icid)
	# print('mountc',mountc)
	os.popen(mountc)

	aufs_cleanc="umount ./%s && rm -fr ./%s" % (icid,icid)
	return


def dir2elf(icid,dirnamearg):
	elflist = []
	paths={}
	for dirnum, dirname in enumerate(dirnamearg.split(","), 1):
		if driver=="overlay" or driver=="overlay2":
			path="./%s/merged%s" % (icid, dirname)
			paths[dirname]=path
		elif driver=="devicemapper":
			path="./%s/rootfs%s" % (icid,dirname)
			paths[dirname]=path##'/home': './75835a67d134/rootfs/home'
		elif driver=="aufs":
			path="./%s%s" % (icid,dirname)
			paths[dirname]=path
	for dirname in paths:
		# print('paths[dirname]',paths[dirname])
		isExists = os.path.exists(paths[dirname])
		if not isExists:
			print ('------ERROR: directory "%s" does not exists in container "%s"' % (dirname, icid))
			continue
		else:
			findelfc = "find %s -type f -exec file {} \; | grep '\<ELF\>' |awk -F ':' '{print $1}'" % (paths[dirname])
			print
			findelfret = os.popen(findelfc, "r")
			for elfnum, elf in enumerate(findelfret, 1):
				elflist.append(elf.strip('\n'))
	print('container:%s, elflist:%s' % (icid, elflist))
	try:
		fp = open(icid + ".log", 'a')
		result = "./result"
		isExists = os.path.exists(result)
		if not isExists:
			os.makedirs(result)
		else:
			for root, dirs, files in os.walk(result, topdown=False):
				for item in files:
					os.remove(root + "/" + item)
		_res = []
		for item in elflist:
			_argv = [sys.argv[0], item]
			loc = result + "/"
			for i in item:
				if i == '.' or i == '/':
					loc += "_"
				else:
					loc += i
			_argv.append(loc)
			try:
				ft = FuncTree()
				_ret = None
				_ret = ft.run(_argv[1], _argv[2])
				#print _ret
				if _ret == True:
					_item = [_argv[2] + ".res", _argv[2] + ".map", _argv[2] + ".info", _argv[2] + ".api", item[item.index(dirname):]]
					_res.append(_item)
					cti = RouteFinder(_item)
					_api_len = cti.run()
					if _api_len < 20:#--------
						if os.path.exists(_item[3]):
							#print os.path.realpath(_item[3]),_item[3]
							os.remove(os.path.realpath(_item[3]))
						#print datetime.datetime.now().strftime('|%Y-%m-%d %H:%M:%S|') + "Router Too SHORT(" + _api_len + ")container id is" + icid + ",path is" + item[4]
						fp.write(datetime.datetime.now().strftime('|%Y-%m-%d %H:%M:%S|') + "Router Too SHORT(" + str(_api_len) + "), container id is " + icid + ", path is " + _item[4] + "\n")
					else:
						fp.write(datetime.datetime.now().strftime('|%Y-%m-%d %H:%M:%S|') + "Angr succ, container id is " + icid + ", path is " + item[item.index(dirname):] + "\n")
				elif _ret == False:
					#print datetime.datetime.now().strftime('|%Y-%m-%d %H:%M:%S|') + "Angr fail, container id is " + icid + ", path is" + item[item.index(dirname):]
					fp.write(datetime.datetime.now().strftime('|%Y-%m-%d %H:%M:%S|') + "Angr fail, container id is " + icid + ", path is " + item[item.index(dirname):] + "\n")
				else:
					fp.write(datetime.datetime.now().strftime('|%Y-%m-%d %H:%M:%S|') + "RuntimeOut, container id is " + icid + ", path is " + item[item.index(dirname):] + "\n")
			except Exception as e:
				#print datetime.datetime.now().strftime('|%Y-%m-%d %H:%M:%S|') + "RuntimeOut, container id is " + icid + ", path is" + item[item.index(dirname):]
				fp.write(datetime.datetime.now().strftime('|%Y-%m-%d %H:%M:%S|') + "Something wrong, container id is " + icid + ", path is " + item[item.index(dirname):] + "\n")
		#print "_res",_res
			
	except Exception as e:
		print datetime.datetime.now().strftime('|%Y-%m-%d %H:%M:%S|') + "something wrong happend!"
	finally:
		fp.close()
		##分析完elf后，需要取消临时目录的挂载并删除该临时目录
		if driver=="overlay" or driver=="overlay2":
			cleanc = overlay_cleanc##两个的卸载和删除一样
		elif driver=="devicemapper":
			cleanc=dm_cleanc
			# print(dm_cleanc)
		elif driver=="aufs":
			cleanc=aufs_cleanc
		os.popen(cleanc)
	return

delete=""
def sigint_handle(signum, frame):
	# print('received signum:', signum)
	path="./"+delete
	isExists = os.path.exists(path)
	if isExists:
		if driver=="overlay" or driver=="overlay2":
			cleanc = overlay_cleanc##两个的卸载和删除一样
		elif driver=="devicemapper":
			cleanc=dm_cleanc
		elif driver=="aufs":
			cleanc=aufs_cleanc
		print('cleanc',cleanc)
		os.popen(cleanc)
	sys.exit(2)
	# return

def main(argv):
	signal.signal(signal.SIGINT, sigint_handle)
	global driver,cidname,imageid,delete
	contlist = ''
	dirname = ''
	dirnamearg = ''
	try:
		opts, args = getopt.getopt(argv,"hc:d:")
	except getopt.GetoptError:
		# print 'usage: getelf.py -c <container id> -d <container dirname>'
		sys.exit(2)
	for opt, arg in opts:
		if opt == '-h':
			# print 'usage: getelf.py -c <container id> -d <container dirname>'
			sys.exit()
		elif opt == '-c':
			contlist = arg
		elif opt == '-d':
			dirnamearg = arg
	print ('container list:', contlist) 
	print ('directory list:', dirnamearg)

	##获取主机上所有容器id/name/镜像id
	lcontlist = []
	# cidname=[]
	command = os.popen("docker ps -a| awk 'NR==2,NR==0 {print $1,$NF}'", "r") #所有容器id/name 
	for lcontnum, lcont in enumerate(command, 1):#lcont:68b4a7cdaf58 mysql
		cidname.append(lcont.split(" ")[0])
		cidname.append(lcont.split(" ")[1].strip('\n'))

	#print '\n', lcontlist
	# imageid=[]
	command = os.popen("docker images | awk 'NR==1 {for(i=1;i<=NF;i++)if($i~/IMAGE/)n=i} NR>1 {print $n}'", "r") #容器镜像id
	for lcontnum, lcont in enumerate(command, 1):
		imageid.append(lcont.strip('\n'))
	
	lcontlist.extend(cidname)
	lcontlist.extend(imageid)
	# print '\n', lcontlist

	##获取主机docker存储驱动
	fp=os.popen("docker info |grep Storage","r")
	driver=fp.read().split(' ')[-1].strip('\n')

	for contnum, icid in enumerate(contlist.split(","), 1):
		if icid in lcontlist: #如果容器id/name/镜像id存在，则查看相应目录下elf
			delete=icid##如果中断，则处理掉该目录
			if driver=="overlay":
				overlay(icid,dirnamearg)
				dir2elf(icid,dirnamearg)
			elif driver=="overlay2":
				overlay2(icid, dirnamearg)
				dir2elf(icid,dirnamearg)
			elif driver=="devicemapper":
				devicemapper(icid, dirnamearg)
				dir2elf(icid,dirnamearg)
			elif driver=="aufs":
				aufs(icid, dirnamearg)
				dir2elf(icid,dirnamearg)
		else:
			print ('------ERROR : The image or container : %s does not exists' % (icid))
			continue
		
if __name__ == "__main__":
	main(sys.argv[1:])
